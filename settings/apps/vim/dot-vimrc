" vim: ft=vim ts=2 sts=2 sw=2 expandtab fenc=utf-8 ff=unix
" Part of GPP(General Puropose Profiles)
" Main Vim configuration

" Origin: Very old
" Last Update: [2024-02-26T03:34:40+0900]

set encoding=utf-8              " Set utf-8 as default encoding.
scriptencoding utf-8

"-----------------------------------------------------------------------------
" XDG Base Dirctory conformance
"-----------------------------------------------------------------------------
if has('persistent_undo')
  set undodir=$XDG_DATA_HOME/vim/undo | call mkdir(&undodir,   'p')
  set undofile
endif

set directory=$XDG_DATA_HOME/vim/swap   | call mkdir(&directory, 'p')
set backupdir=$XDG_DATA_HOME/vim/backup | call mkdir(&backupdir, 'p')
set viewdir=$XDG_DATA_HOME/vim/view     | call mkdir(&viewdir, 'p')

if !has('nvim')
  set viminfo='1000,s100,<1000,:50000,/50000,!,h,n$XDG_DATA_HOME/vim/viminfo
endif

set runtimepath^=$XDG_CONFIG_HOME/vim,$XDG_DATA_HOME/vim
set packpath^=$XDG_DATA_HOME/vim,$XDG_CONFIG_HOME/vim
set packpath+=$XDG_CONFIG_HOME/vim/after,$XDG_DATA_HOME/vim/after

let g:netrw_home = $XDG_DATA_HOME.'/vim'
call mkdir($XDG_DATA_HOME.'/vim/spell', 'p')

"----------------------------------------------------------------------------
" Viminfo settings [:help viminfo]
"----------------------------------------------------------------------------
" save marks in mru 1000 files.
" save registers up to 100KB.
" save registers up to 1000 lines.
" save command history up to 50000 lines.
" save search history up to 50000 lines.
" save ALL_ALPHABET_VARIABLES.
" disable hlsearch when viminfo file read.
" set viminfo^='1000,s100,<1000,:50000,/50000,!,h

"-----------------------------------------------------------------------------
" Read configuration files
"-----------------------------------------------------------------------------
runtime conf.d/keymap.vim   " Keymap definition
runtime conf.d/vimplug.vim  " Vim-Plug

set runtimepath+=$VIMRUNTIME,$XDG_CONFIG_HOME/vim/after

"-----------------------------------------------------------------------------
" Path settings
"-----------------------------------------------------------------------------
if has('macunix')
  set path^=/usr/local/include
  set path^=/opt/homebrew/include
  " set path+=${HOME}/Library/Arduino15/packages/**
  " set path+=${HOME}/Arduino/libraries/**
  " set path+=/Applications/Arduino.app/Contents/Java/hardware/**
endif

"----------------------------------------------------------------------------
" General settings [http://www.geek.sc/archives/977]
"----------------------------------------------------------------------------
filetype plugin indent on       " Use filetype plugin and auto indent
set fileencodings=utf-8,euc-jp,sjis,cp932,iso-2022-jp-3,iso-2022-jp,eucjp-ms,euc-jisx0213,ucs-bom
set fileformats=unix,dos,mac
set backspace=indent,eol,start  " allow backspacing over everything in insert mode
set autoindent                  " always set autoindenting on
set noswapfile                  " not to make swap file.
set nowritebackup               " not to make backup file.
set nobackup                    " not to backup
set history=50                  " keep 50 lines of command line history
set textwidth=0                 " default maximum width of text(0 means never use auto line break)
set tabstop=8                   " default tab width
set shiftwidth=0                " default indent width(0 means same as tabstop)
set noexpandtab                 " expand tab to space
set cursorline                  " show cursor line indicator
set cursorlineopt=both          " number / line / both
set number                      " show line number
set noruler                     " show the cursor position all the time
set laststatus=2                " when the status line would be shown(2 means always)
"set statusline=%F%m%r%h%w\ \ \ \ %y\ lines:%L\%=(%l,%v)\ [%{&fileencoding}][%{&ff}]
set nohlsearch                  " not to highlight matching part
set incsearch                   " use incremental search
set ignorecase                  " ignore case distinctions
set showmatch                   " briefly jump to matched bracket
set noshowmode                  " not to show current mode at bottommost row
set title                       " allow vim change terminal's title
set virtualedit=block           " allow free cursor in visual block mode
set whichwrap=b,s,[,],<,>       " allow these keys move next or previous line(see help)
" set ambiwidth=double            " a magic to deal with full width characters well
set ambiwidth=single            " Thnks to vim-ambiwidth, it works fine with single width
set wildmenu                    " use command line completion
set wildmode=longest,full       " completion mode(see help)
set noerrorbells                " no beep nor screen flush for error messages
set novisualbell                " no flush screen instead of beeping
set visualbell t_vb=            " visualbell is void(do nothing)
set list                        " show control characters such as tab or EOL.
"set listchars=tab:»\ ,eol:↲,space:␣,trail:･,extends:⟩,precedes:⟨
set listchars=tab:»\ ,eol:↲,trail:･,extends:⟩,precedes:⟨
set showbreak=↪                 " string to put at the start of line wrapped. Useful values are '>' or '+++'
set hidden                      " not to unload and to hide the buffer when abondoned
set nopaste                     " put Vim in Paste mode which is useful for pasting some text to Vim.
set modeline                    " use modeline
set noshowcmd                   " show command
set cmdheight=2                 " height of command line
set scrolloff=5                 " mergin lines of vertical scrolling
set helplang=ja,en              " Prefer Japanse help

" No need to escape regular expression meta characters when search(very magic mode)
" nnoremap /  /\v

"=============================================================================
" Completion settings
" [https://note.com/yasukotelin/n/na87dc604e042]
"=============================================================================
set completeopt=menuone,noinsert
" Prohibit entering cariage return on popup menu
inoremap <expr><CR>  pumvisible() ? "<C-y>" : "<CR>"
" Don't automatically enter the selecting value on popup menu
inoremap <expr><C-n> pumvisible() ? "<Down>" : "<C-n>"
inoremap <expr><C-p> pumvisible() ? "<Up>" : "<C-p>"

"------ Settigs for AutoCompletion.vim
" 補完を開始するキー入力数
" let MyAutoComplete_StartLength = 2
let MyAutoComplete_StartLength = 3

" デフォルトの補完コマンド
" let MyAutoComplete_cmd = "\<C-n>\<C-p>"
"
" デフォルト補完候補はVimのcompleteオプションに従って検索されます。
" set complete = '.,w,b,u,t,i'
" (詳細は :help 'complete')

" 補完候補はsmartcaseの設定値にかかわらず、smartcaseを有効にして検索されま
" す。無効にしたい場合は.vimrcに以下を設定してください。
" let MyAutoComplete_smartcase_Control = 0

" ファイルタイプ別に補完コマンドの設定を変更可能です。
" ファイルタイプcppの場合のcompleteオプション
" let cpt_cpp = '.,w,b,u,t,i'
" ファイルタイプcppの場合はオムニ補完を指定 (詳細は :help 'omnifunc')
" let cptcmd_cpp = "\<C-x>\<C-o>\<C-p>"

" UltiSnips settings
let g:UltiSnipsSnippetDirectories=['ultisnips']
let g:UltiSnipsExpandTrigger='<tab>'
let g:UltiSnipsJumpForwardTrigger='<c-b>'
let g:UltiSnipsJumpBackwardTrigger='<c-z>'

"=============================================================================
" Settings for Airline(lean & mean status/tabline for vim that's light as air )
" [https://github.com/vim-airline/vim-airline]
"=============================================================================
" let g:airline_theme='light'
" let g:airline_theme='tomorrow'
" let g:airline_theme='solarized'
" let g:airline_solarized_bg='dark'
" let g:airline_theme='gruvbox'
let g:airline_theme='ayu_dark'

" let g:airline_mode_map = {
"       \ 'n'  : ' [NORMAL] ',
"       \ 'i'  : ' <INSERT> ',
"       \ 'R'  : ' >REPLACE<',
"       \ 'c'  : ' [COMMAND]',
"       \ 'v'  : ' [VISUAL] ',
"       \ 'V'  : ' [V-LINE] ',
"       \ '' : ' [V-BLOCK]',
"       \ }

let g:airline_mode_map = {
      \ '__'  : '-',
      \ 'n'  : '[N]',
      \ 'ni' : 'N->[I]',
      \ 'niI': 'N->[I]',
      \ 'no' : 'Oper',
      \ 'i'  : '<I>',
      \ 'ic' : '<IC>',
      \ 'ix' : '<C-X>',
      \ 'in' : 'I->[N]',
      \ 'R'  : '>R<',
      \ 'Rv' : 'R->[v]',
      \ 'v'  : '[v]',
      \ 'V'  : '[V]',
      \ '' : 'V-B',
      \ 's'  : '[s]',
      \ 'S'  : '[S]',
      \ '' : '[^S]',
      \ 'c'  : 'Cmnd',
      \ 't'  : 'TERM',
      \ 'multi' : '[M]',
      \ }

let g:airline_filetype_overrides = {
      \ 'coc-explorer':  [ 'CoC Explorer', '' ],
      \ 'defx':  ['defx', '%{b:defx.paths[0]}'],
      \ 'fugitive': ['fugitive', '%{airline#util#wrap(airline#extensions#branch#get_head(),80)}'],
      \ 'gundo': [ 'Gundo', '' ],
      \ 'help':  [ 'Help', '%f' ],
      \ 'minibufexpl': [ '(mbe)', '' ],
      \ 'nerdtree': [ get(g:, 'NERDTreeStatusline', 'NERD'), '' ],
      \ 'startify': [ 'startify', '' ],
      \ 'vim-plug': [ 'Plugins', '' ],
      \ 'vimfiler': [ 'vimfiler', '%{vimfiler#get_status_string()}' ],
      \ 'vimshell': ['vimshell','%{vimshell#get_status_string()}'],
      \ 'vaffle' : [ 'Vaffle', '%{b:vaffle.dir}' ],
      \ }

"-+-+-+- Airline tab settings -+-+-+-
" let g:airline#extensions#tabline#enabled = 1
" let g:airline#extensions#tabline#show_buffers = 1
" let g:airline#extensions#tabline#tab_nr_type = 1
" let g:airline#extensions#tabline#fnamemod = ':t'
" let g:airline#extensions#tabline#formatter = 'unique_tail'
  " normal / visual / select / op. pend.
"-+-+-+- Airline status bar settings -+-+-+-
"let g:airline_section_a = airline#section#create(['mode', 'crypt', 'paste', 'spell', 'iminsert'])
"let g:airline_section_b = airline#section#create(['hunks', 'branch'])
"let g:airline_section_c = airline#section#create(['file'])
"let g:airline_section_x = airline#section#create(['tagbar', 'filetype'])
"let g:airline_section_y = airline#section#create(['ffenc'])
"let g:airline_section_z = airline#section#create(['linenr', 'maxlinenr'])

"-+-+-+- Airline font and symbols -+-+-+-
let g:airline_powerline_fonts = 1
let g:Powerline_symbols = 'fancy'

if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif

"let g:airline_left_sep = '»'
"let g:airline_left_sep = '▶'
"let g:airline_left_sep = ''
"let g:airline_left_alt_sep = ''
let g:airline_left_sep = ''
let g:airline_left_alt_sep = ''

"let g:airline_right_sep = '«'
"let g:airline_right_sep = '◀'
"let g:airline_right_sep = ''
"let g:airline_right_alt_sep = ''
let g:airline_right_sep = ''
let g:airline_right_alt_sep = ''

let g:airline_symbols.linenr = '☰ '
"let g:airline_symbols.linenr = '␊'
"let g:airline_symbols.linenr = '␤'
"let g:airline_symbols.linenr = '¶'

let g:airline_symbols.maxlinenr = ''
"let g:airline_symbols.maxlinenr = '㏑'
"let g:airline_symbols.maxlinenr = ''

"let g:airline_symbols.branch = ''
let g:airline_symbols.branch = '⎇'

"let g:airline_symbols.paste = '<PASTE>'
let g:airline_symbols.paste = 'ρ'
"let g:airline_symbols.paste = 'Þ'
"let g:airline_symbols.paste = '∥'

let g:airline_symbols.readonly = ''
let g:airline_symbols.crypt = '🔒'
let g:airline_symbols.spell = 'Ꞩ'       " Spell check
let g:airline_symbols.notexists = '∄'   " Sign for non-git file
let g:airline_symbols.whitespace = 'Ξ' " Warning sign for white spaces

"------------------------------------------------
" Airline extensions
"------------------------------------------------
"-+-+-+- Airline with Ale(Syntax checker) -+-+-+-
let g:airline#extensions#ale#enabled = 1
let airline#extensions#ale#error_symbol = 'E:'
let airline#extensions#ale#warning_symbol = 'W:'
let airline#extensions#ale#show_line_numbers = 1
let airline#extensions#ale#open_lnum_symbol = '(L'
let airline#extensions#ale#close_lnum_symbol = ')'

"-+-+-+- Airline with Tagbar -+-+-+-
let g:airline#extensions#tagbar#enabled = 1
let g:airline#extensions#tagbar#flags = 's'

"=============================================================================
" From How to boost your Vim productivity
" [https://sheerun.net/2014/03/21/how-to-boost-your-vim-productivity/]
"=============================================================================
" I. Space is your Leader
let mapleader = "\<Space>"

" II. Map your most frequent actions to Leader
"-- Type <Space>o to open a new file
"nnoremap <Leader>o :CtrlP<CR>
"-- Type <Space>w to save file (a lot faster than :w<Enter>)
nnoremap <Leader>w :w<CR>
"-- Enter visual line mode with <Space><Space>
nmap <Leader><Leader> V
"-- Copy, cut & paste to system clipboard with <Leader>y, <Leader>d and <Leader>p
"set clipboard&            " reset clipboard as default
"set clipboard^=unnamed    " use system's clipboard
vmap <Leader>y "+y
vmap <Leader>d "+d
vmap <Leader>p "+p
vmap <Leader>P "+P
nmap <Leader>p "+p
nmap <Leader>P "+P

" III. Use region expanding
vmap v <Plug>(expand_region_expand)
vmap <C-v> <Plug>(expand_region_shrink)

" IV. Discover text search object
vnoremap <silent> s //e<C-r>=&selection=='exclusive'?'+1':''<CR><CR>
    \:<C-u>call histdel('search',-1)<Bar>let @/=histget('search',-1)<CR>gv
omap s :normal vs<CR>

" V. Invent more awesome key mappings
"-- Automatically jump to end of text you pasted: paste multiple lines multiple times with simple ppppp
vnoremap <silent> y y`]
vnoremap <silent> p p`]
nnoremap <silent> p p`]
"-- Prevent replacing paste buffer on paste: select some text and paste over it without replacing paste buffer
function! RestoreRegister()
  let @" = s:restore_reg  " 's:' means script local variable(:help usr_41)
  return ''
endfunction
function! s:Repl()
  let s:restore_reg = @"
  return "p@=RestoreRegister()\<cr>"
endfunction
" vp doesn't replace paste buffer
vmap <silent> <expr> p <sid>Repl()

"-- Type 12<Enter><Enter> to go to line 12 (12G breaks my wrist)
"-- Hit Enter to go to end of file.
"-- Hit Backspace to go to beginning of file.
nnoremap <CR><CR> G
nnoremap <BS><BS> gg
"-- Quickly select text you just pasted:
noremap gV `[v`]
"-- [Obsolete] Stop opening command history.
" map q: :q
"-- '; = :' in this world.
noremap ; :

"-- Force write with root privilege
cabbrev w!! w !sudo tee > /dev/null %

"=============================================================================
" Exit from any mode by Ctrl-C(Needless??)
"=============================================================================
" normal / visual / select / op. pend.
noremap  <C-c> <ESC>
" visual / select
vnoremap <C-c> <ESC>
" select
snoremap <C-c> <ESC>
" visual
xnoremap <C-c> <ESC>
" op. pend.
onoremap <C-c> <ESC>
" insert
inoremap <expr><C-c> pumvisible()?"<C-e>":"<ESC>"

" Don't back 1 charactor when leaving insert mode
augroup DoNotBack
  autocmd!
  autocmd InsertLeave * call MyInsertLeave()
augroup END

function! MyInsertLeave()
  if col('.') != 1
    exec 'normal! l'
  endif
endfunction

"=============================================================================
" From 若干Emacs風味なvimのキー設定
" [https://sites.google.com/site/fudist/Home/vim-nihongo-ban/tips/vim-key-emacs]
"=============================================================================
" sepが空でなければ、sepをセパレータとしてジャンプ。見つからなければ見かけの行頭へ。
" カーソル位置が見かけの行頭の場合は真の行頭へ。
function! MyJumptoBol(sep)
  if col('.') == 1
    call cursor(line('.')-1, col('$'))
    call cursor(line('.'), col('$'))
    return ''
  endif
  if matchend(strpart(getline('.'), 0, col('.')), '[[:blank:]]\+') >= col('.')-1
    silent exec 'normal! 0'
    return ''
  endif
  if a:sep !=? ''
    call search('[^'.a:sep.']\+', 'bW', line('.'))
    if col('.') == 1
      silent exec 'normal! ^'
    endif
    return ''
  endif
  exec 'normal! ^'
  return ''
endfunction

" sepが空でなければ、sepをセパレータとしてジャンプ。見つからなければ行末へ。
function! MyJumptoEol(sep)
  if col('.') == col('$') - 1
    silent exec 'normal! w'
    return ''
  endif
  if a:sep !=? ''
    let prevcol = col('.')
    call search('['.a:sep.']\+[^'.a:sep.']', 'eW', line('.'))
    if col('.') != prevcol
      return ''
    endif
  endif
  call cursor(line('.'), col('$'))
  return ''
endfunction

" IMEの状態とカーソル位置保存のため<C-r>を使用してコマンドを実行。
function! MyExecExCommand(cmd, ...)
  let saved_ve = &virtualedit
  let index = 1
  while index <= a:0
    if a:{index} ==# 'onemore'
      silent setlocal virtualedit+=onemore
    endif
    let index = index + 1
  endwhile

  silent exec a:cmd
  if a:0 > 0
    silent exec 'setlocal virtualedit='.saved_ve
  endif
  return ''
endfunction

" 行末でも停止する単語単位移動コマンド
function! MyMoveWord_i(cmd)
  let isEol = 0
  if col('$') == col('.')
    let isEol = 1
  endif
  let prevline = line('.')
  silent exec 'normal! '.a:cmd
  if line('.') == prevline
    return ''
  endif
  if a:cmd ==? 'w'
    if isEol == 0
      call cursor(prevline, 0)
      call cursor(line('.'), col('$'))
    endif
    if line('.') - prevline > 1
      call cursor(prevline+1, 0)
      call cursor(line('.'), col('$'))
    endif
  elseif a:cmd ==? 'b'
    call cursor(line('.'), col('$'))
    if prevline - line('.') > 1
      call cursor(prevline-1, 0)
      call cursor(line('.'), col('$'))
    endif
  endif
  return ''
endfunction

"-- Jump to BOL/EOL
vnoremap <C-a> 0
vnoremap <C-e> $
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
nnoremap <silent> <C-a> :call MyJumptoBol('　。、．，／！？「」')<CR>
nnoremap <silent> <C-e> :call MyJumptoEol('　。、．，／！？「」')<CR>
inoremap <silent> <C-a> <C-r>=MyJumptoBol('　。、．，／！？「」')<CR>
" Don't overwrite the completion abort command in CTRL-X mode
inoremap <silent> <expr> <C-e> pumvisible() ? "<C-e>" : "<C-r>=MyJumptoEol('　。、．，／！？「」')<CR>"

"-- Delete a character just after cursor(=Del key)
nnoremap <C-d> <Del>
cnoremap <C-d> <Del>
inoremap <silent> <Del> <C-g>u<Del>
inoremap <silent> <C-d> <C-g>u<Del>

"-- Delete a word
function DeleteForwardWord()
  silent execute 'normal! dw'
  return ''
endfunction

function DeleteBackwardWord()
  silent execute 'normal! db'
  return ''
endfunction

noremap  <silent> <M-d>  :call DeleteForwardWord()<CR>
noremap  <silent> <M-BS> :call DeleteBackwardWord()<CR>
noremap! <silent> <M-d>  <C-r>=DeleteForwardWord()<CR>
noremap! <silent> <M-BS> <C-w>

"-- Delete characters from cursor to EOL
nnoremap <C-k> D
inoremap <silent> <C-k> <C-g>u<C-r>=MyExecExCommand('normal! D','onemore')<CR>

"-- Move word by word
noremap  <silent> <M-Right> :call MyMoveWord_i('W')<CR>
noremap! <silent> <M-Right> <C-r>=MyMoveWord_i('W')<CR>
noremap  <silent> <M-Left>  :call MyMoveWord_i('B')<CR>
noremap! <silent> <M-Left>  <C-r>=MyMoveWord_i('B')<CR>

"=============================================================================
" Made by [hmr]
"=============================================================================
" ノーマルモードでaキーを押した場合、カーソルが行末にあればa、それ以外はiとして動作する
function! AppendOrInsert()
  if col('.') == col('$') - 1
    exec 'startinsert!'
  else
    exec 'startinsert'
  endif
endfunction
nmap <silent> a :call AppendOrInsert()<CR>

" 挿入モードでもCtrl-zでサスペンドする
inoremap <C-z> <ESC><C-z>

" Ctrl+Arrow: move between the windows
noremap   <silent><C-Left>  :wincmd h<CR>
noremap   <silent><C-Down>  :wincmd j<CR> " or <C-w>j
noremap   <silent><C-Up>    :wincmd k<CR> " or <C-w>k
noremap   <silent><C-Right> :wincmd l<CR> " or <C-w>l
noremap!  <silent><C-Left>  <ESC>:wincmd h<CR> " or <C-w>h
noremap!  <silent><C-Down>  <ESC>:wincmd j<CR> " or <C-w>j
noremap!  <silent><C-Up>    <ESC>:wincmd k<CR> " or <C-w>k
noremap!  <silent><C-Right> <ESC>:wincmd l<CR> " or <C-w>l

" Shift+Ctrl+Arrow: move between the tabs
noremap   <silent><C-S-Left>  :tabn<CR>
noremap   <silent><C-S-Right> :tabp<CR>       " or <C-w>l
noremap!  <silent><C-S-Left>  <ESC>:tabn<CR>  " or <C-w>h
noremap!  <silent><C-S-Right> <ESC>:tabp<CR>  " or <C-w>l

" Testing for bash-readline
let readline_has_bash = 1

" PageUp/PageDown
function PageUpFull()
  silent execute 'normal!' "\<C-B>"
  return ''
endfunction

function PageDownFull()
  silent execute 'normal!' "\<C-F>"
  return ''
endfunction

function PageUpHalf()
  silent execute "normal! \<C-U>"
  silent execute 'normal! zz'
  return ''
endfunction

function PageDownHalf()
  silent execute "normal! \<C-D>"
  silent execute 'normal! zz'
  return ''
endfunction

noremap  <silent> <PageUp>     :call PageUpFull()<CR>
noremap  <silent> <PageDown>   :call PageDownFull()<CR>
noremap! <silent> <PageUp>     <C-r>=PageUpFull()<CR>
noremap! <silent> <PageDown>   <C-r>=PageDownFull()<CR>
noremap  <silent> <S-PageUp>   :call PageUpHalf()<CR>
noremap  <silent> <S-PageDown> :call PageDownHalf()<CR>
noremap! <silent> <S-PageUp>   <C-r>=PageUpHalf()<CR>
noremap! <silent> <S-PageDown> <C-r>=PageDownHalf()<CR>
vnoremap <PageUp>     <C-b>
vnoremap <PageDown>   <C-f>
vnoremap <S-PageUp>   <C-u>
vnoremap <S-PageDown> <C-d>

"-----------------------------------------------------------------------------
" Capture(): redirect command output to file [https://gist.github.com/hokaccha/380535]
"-----------------------------------------------------------------------------
" Capture {{{
command!
  \ -nargs=1
  \ -complete=command
  \ Capture
  \ call Capture(<f-args>)

function! Capture(cmd)
  redir => result
  silent execute a:cmd
  redir END

  let bufname = 'Capture: ' . a:cmd
  new
  setlocal bufhidden=unload
  setlocal nobuflisted
  setlocal buftype=nofile
  setlocal noswapfile
  silent file `=bufname`
  silent put =result
  1,2delete _
endfunction
" }}}

"-----------------------------------------------------------------------------
" [Meta-n] Toggle line number (https://qiita.com/smison/items/f392037f1164eba5cc74)
"-----------------------------------------------------------------------------
function ToggleNumber()
  if &number
    setlocal nonumber
  else
    setlocal number
  endif
endfunction
nmap <silent> <M-n> :silent call ToggleNumber()<CR>

"-----------------------------------------------------------------------------
" [Meta-h] Toggle search result highlighting (http://d.hatena.ne.jp/h1mesuke/20080327/p1)
"-----------------------------------------------------------------------------
function ToggleHighlight()
  if &hlsearch
    setlocal nohlsearch
  else
    setlocal hlsearch
  endif
endfunction
nmap <silent> <M-h> :silent call ToggleHighlight()<CR>

"-----------------------------------------------------------------------------
" [Meta-l] Toggle control character
"-----------------------------------------------------------------------------
function ToggleList()
  if &list
    setlocal nolist
  else
    setlocal list
  endif
endfunction
nmap <silent> <M-l> :silent call ToggleList()<CR>

"-----------------------------------------------------------------------------
" [Meta-p] Toggle paste mode
"-----------------------------------------------------------------------------
function TogglePaste()
  if &paste
    setlocal nopaste
  else
    setlocal paste
  endif
endfunction
nmap  <silent> <M-p> :silent call TogglePaste()<CR>

"-----------------------------------------------------------------------------
" [Meta-g] Toggle GitGutter
"-----------------------------------------------------------------------------
nmap <silent> <M-g> :silent call gitgutter#toggle()<CR>

"=============================================================================
" Settings for autocmd
"=============================================================================
if has('autocmd')
  augroup defgrp1
    autocmd!
    "In text files, always limit the width of text to 78 characters
    " autocmd BufRead *.txt set tw=78

    "When editing a file, always jump to the last cursor position
    autocmd BufReadPost *
          \ if line("'\"") > 0 && line ("'\"") <= line("$") |
          \     exe "normal! g'\"" |
          \     exe "normal! zz'\"" |
          \ endif

    "don't write swapfile on most commonly used directories for NFS mounts or USB sticks
    " autocmd BufNewFile,BufReadPre /media/*,/mnt/* set directory=~/tmp,/var/tmp,/tmp

    "start with spec file template
    " autocmd BufNewFile *.spec 0r /usr/share/vim/vimfiles/template.spec

    " Trying to disable textwidth limitation.
    " autocmd FileType text setlocal textwidth=0

    " CD to the directory where the file editing exist.
    autocmd BufEnter *  execute ":lcd " . expand("%:p:h")
  augroup END
endif

"=============================================================================
" NERDTree(A tree explorer plugin for vim) [https://github.com/preservim/nerdtree]
"=============================================================================
map <Leader>t :NERDTreeToggle<CR>
augroup nertree_g
  autocmd!
  autocmd BufEnter * if (winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree()) | q | endif
augroup END
let g:NERDTreeDirArrowExpandable = '▸'
let g:NERDTreeDirArrowCollapsible = '▾'

" 表示幅
let g:NERDTreeWinSize=30
" ブックマークを表示
let g:NERDTreeShowBookmarks=1
" 親ディレクトリへ移動
let g:NERDTreeMapUpdir='<C-u>'
" ファイルの開き方
let g:NERDTreeMapOpenSplit='<C-j>'
let g:NERDTreeMapOpenVSplit='<C-l>'
" ファイルを開いたらNERDTreeを閉じる
let g:NERDTreeQuitOnOpen=1
" 隠しファイルを表示
let g:NERDTreeShowHidden=0
" 非表示ファイル
let g:NERDTreeIgnore=['\.git$', '\.clean$', '\.swp$', '\.bak$', '\~$']

augroup vimrc_nerdtree
  autocmd!
  " 他のバッファをすべて閉じた時にNERDTreeが開いていたらNERDTreeも一緒に閉じる。
  autocmd bufenter * if (winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree()) | q | endif

  " Tree内では5ずつ移動する
  autocmd FileType nerdtree nnoremap 5j
  autocmd FileType nerdtree nnoremap 5k
augroup END

"=============================================================================
" Settings for NERD Commenter
"=============================================================================
" Create default mappings
let g:NERDCreateDefaultMappings = 1
" Add spaces after comment delimiters by default
let g:NERDSpaceDelims = 1
" Use compact syntax for prettified multi-line comments
let g:NERDCompactSexyComs = 1
" Align line-wise comment delimiters flush left instead of following code indentation
let g:NERDDefaultAlign = 'left'
" Set a language to use its alternate delimiters by default
let g:NERDAltDelims_java = 1
" Add your own custom formats or override the defaults
let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }
" Allow commenting and inverting empty lines (useful when commenting a region)
let g:NERDCommentEmptyLines = 1
" Enable trimming of trailing whitespace when uncommenting
let g:NERDTrimTrailingWhitespace = 1
" Enable NERDCommenterToggle to check all selected lines is commented or not
let g:NERDToggleCheckAllLines = 1

" While the plugin does not directly support motions,
" you can leverage its support for selections to do something very similar.
" For example, to add motions to toggle comments on the paragraph text object you could use:
"nnoremap <silent> <leader>c} V}:call NERDComment('x', 'toggle')<CR>
"nnoremap <silent> <leader>c{ V{:call NERDComment('x', 'toggle')<CR>

"=============================================================================
" quickhl.vim(Quickly highlight multiple word) [https://github.com/t9md/vim-quickhl]
"=============================================================================
nmap <Leader>m <Plug>(quickhl-manual-this)
xmap <Leader>m <Plug>(quickhl-manual-this)
nmap <Leader>r <Plug>(quickhl-manual-reset)
xmap <Leader>r <Plug>(quickhl-manual-reset)
nmap <Leader>c <Plug>(quickhl-manual-clear)
vmap <Leader>c <Plug>(quickhl-manual-clear)
"nmap <Space>w <Plug>(quickhl-manual-this-whole-word)
"xmap <Space>w <Plug>(quickhl-manual-this-whole-word)
"nmap <Space>j <Plug>(quickhl-cword-toggle)
"nmap <Space>] <Plug>(quickhl-tag-toggle)
"map H <Plug>(operator-quickhl-manual-this-motion)

"=============================================================================
" Settings for cscope [:help if_cscop]
"=============================================================================
" if has('cscope') && filereadable('/usr/local/bin/cscope')
"   set cscopeprg=/usr/local/bin/cscope
"   set cscopetagorder=0
"   set cscopetag
"   set nocscopeverbose
"   " add any database in current directory
"   if filereadable('cscope.out')
"     cs add cscope.out
"     " else add database pointed to by environment
"   elseif $CSCOPE_DB !=? ''
"     cs add $CSCOPE_DB
"   endif
"   set cscopeverbose
" endif

"=============================================================================
" Settings for terminal, color, visual and syntax highlighting
"=============================================================================

" Enable paste bracketting
if &term !~? 'xterm'  " Except for xterm
  let &t_BE = "\e[?2004h" " Enter paste bracketting
  let &t_BD = "\e[?2004l" " Exit  paste bracketting
  exec "set t_PS=\e[200~"
  exec "set t_PE=\e[201~"
endif

if &t_Co > 2 || has('gui_running')  " Only for color environment

  " Reset and enable syntax highlighting(for w/o reset use ':syntax enable')
  syntax on

  if has('termguicolors')
    set termguicolors  " true color support
    if &term !~? 'xterm'  " for $TERM != 'xterm'
      let &t_8f = "\e[38;2;%lu;%lu;%lum" " Default foreground color
      let &t_8b = "\e[48;2;%lu;%lu;%lum" " Default background color
    endif
  endif

  " Color scheme settings
  try
    set background=dark

    " colorscheme monokai

    " -- settings for molokai
    " let g:molokai_original=1
    " let g:rehash256=1
    " colorscheme molokai

    " -- settings for sublime-monokai
    " let g:sublimemonokai_term_italic=1

    " -- settings for gruvbox
    let g:gruvbox_bold = 1
    let g:gruvbox_italic = 1
    let g:gruvbox_underline = 1
    let g:gruvbox_undercurl = 1
    let g:gruvbox_inverse = 1
    " let g:gruvbox_guisp_fallback = 1  " guisp is color of undercurl
    let g:gruvbox_improved_strings = 1
    let g:gruvbox_improved_warnings = 1
    let g:gruvbox_termcolors = 256
    let g:gruvbox_invert_indent_guides = 1

    let g:gruvbox_contrast_dark  = 'medium'
    " let g:gruvbox_contrast_light = 'medium'
    " let g:gruvbox_invert_tabline = 1

    " -- with vim's mainline Java
    " let java_comment_strings=1
    " let java_highlight_functions=1
    " let java_highlight_java_lang_ids=1

    " -- with 'fatih/vim-go'
    " let g:go_highlight_format_strings=1
    " let g:go_highlight_function_arguments=1
    " let g:go_highlight_function_calls=1
    " let g:go_highlight_functions=1
    " let g:go_highlight_operators=1
    " let g:go_highlight_types=1
    " let g:go_highlight_extra_types=1
    " let g:go_highlight_fields=1
    " let g:go_highlight_generate_tags=1
    " let g:go_highlight_variable_assignments=1
    " let g:go_highlight_variable_declarations=1

    " with 'StanAngeloff/php.vim'
    " let g:php_var_selector_is_identifier=1

    " colorscheme sublimemonokai
    colorscheme gruvbox
  catch
    colorscheme default
  endtry

  " Use italic font for comment
  highlight Comment cterm=italic

  " show vertical line at col 100 if possible
  if (exists('+colorcolumn'))
    set colorcolumn=100
  endif

  if g:colors_name ==# 'molokai'
    if has('termguicolors')
      highlight Comment   guifg=#95917E
      highlight Visual    guibg=#af5f00
      highlight VisualNOS guibg=#af5f00

      " Change background color by mode
      augroup InsertHook
        autocmd!
        autocmd InsertEnter * highlight Normal guibg=#263026
        autocmd InsertLeave * highlight Normal guibg=#262626
      augroup END
    else
      highlight Comment   ctermfg=247
      highlight Visual    ctermbg=130
      highlight VisualNOS ctermbg=130
    endif
  endif

  if g:colors_name ==# 'sublimemonokai'
    highlight SignColumn guibg=#383a3e
  endif

endif

"-- Change cursor color depends on InputMethod status
if has('gui_running') && (has('xim') || has('multi_byte_ime'))
  "highlight Cursor guifg=NONE guibg=Green
  highlight CursorIM guifg=Black guibg=Red

  highlight Cursor guifg=white
endif

"-- Change cursor shape by mode
if has('vim_starting')
  " 1-2: Block
  " 3-4: Underline
  " 5-6: Vertical
  " (*) Odd number is with blinking
  let &t_EI .= "\e[1 q"   " Normal mode
  let &t_SI .= "\e[5 q"   " Insert mode
  let &t_SR .= "\e[6 q"   " Replace mode
endif

"-- ScroolUp/ScrollDown by mouse wheel
"map <S-ScrollWhellUp> <C-Y>
"map <S-ScrollWhellDown> <C-U>

"=============================================================================
" Additional settings for MacVim
"=============================================================================
if has('gui_macvim')
  set macmeta
  set macligatures
  set macthinstrokes
  set antialias

  " Font settings
  " set guifont=Cica-Regular:h15
  " set guifont=MesloLGS\ NF\ Regular:h13
  " set guifont=RictyDiminished-Regular:h15
  " set guifont=PlemolJP\ Console\ Regular:h15
  set guifont=PlemolJP\ Console\ NF\ Regular:h14
  " set guifontwide=Cica-Regular:h14
  " set guifontwide=PlemolJP\ Console\ Regular:h15
  set guifontwide=PlemolJP\ Console\ NF\ Regular:h14

  " Font test
  " Strings:
  "   (EN) Hello world
  "   (RU) Привет, мир
  "   (CZ) Ahoj světe
  "   (HI) नमस्ते दुनिया
  "   (TH) สวัสดีชาวโลก
  "   (VN) Chào thế giới
  "   (KR) 안녕하세요 세계
  "   (CN) 你好世界
  "   (JP) 本日は晴天なり。
  " Chars_and_Ligatures:
  "   *a **abc) ***abc
  "   ++a a--- a->b, c-->d, e<-f, g<--h, i=>j, k==>l
  "   www != ^= ~= ~@
  "   <~> <~~ --> === =:=
  " PowerLine:
  "   ro=, ws=☲, lnr=☰, mlnr=, br=, nx=Ɇ, crypt=🔒
  "   ro=⊝, ws=☲, lnr=☰, mlnr=㏑, br=ᚠ, nx=Ɇ, crypt=🔒
  "      
  " Emoji:
  "   😀😂🙃

  " MacVim now supports trasparency!
  set transparency=6
  set blurradius=10

  " Supress cursor brinking [http://www.linuxpowertop.org/known.php]
  let &guicursor .= ',a:blinkon0'

  " Terminal setting
  let &t_ZH = '[3m'   " Enter italic mode
  let &t_ZR = '[23m'  " Exit italic mode

  " WinResizer can handle MacVim's window
  let g:winresizer_gui_enable = 1
  " Don't set MacVim's default color scheme and keymaps
  let macvim_skip_colorscheme = 1
  let macvim_skip_cmd_opt_movement = 1
  let macvim_hig_shift_movement = 1
endif

" "=============================================================================
" " Settings for fzf.vim
" "=============================================================================
" set runtimepath+=/usr/local/opt/fzf
" let g:fzf_buffers_jump = 1
" nnoremap <silent> <Leader>ff :<C-u>Ag<CR>
" nnoremap <silent> <Leader>fh :<C-u>History<CR>
" nnoremap <silent> <Leader>ft :<C-u>call fzf#vim#tags(expand('<cword>'))<CR>
" nnoremap <silent> <Leader>fb :<C-u>Buffers<CR>
" nnoremap <silent> <Leader>fgs :<C-u>GFiles?<CR>
" nnoremap <silent> <Leader>fgf :<C-u>GFiles<CR>
" nnoremap <silent> <Leader>fm :<C-u>Marks<CR>
" let g:fzf_layout = { 'down': '30%' }
" let g:fzf_action = {
"       \ 'ctrl-t': 'tab split',
"       \ 'ctrl-j': 'split',
"       \ 'ctrl-l': 'vsplit' }
"
" augroup vimrc_fzf
"   autocmd!
"   autocmd FileType fzf tnoremap <buffer> <leader>z <Esc>
" augroup END

" "=============================================================================
" "Settings for vim-easymotion
" "=============================================================================
" map  <Leader>e <Plug>(easymotion-prefix)
" " Move to word
map  <Leader>e <Plug>(easymotion-bd-w)
nmap <Leader>e <Plug>(easymotion-overwin-w)
" " Move to line
map  <Leader>l <Plug>(easymotion-bd-jk)
nmap <Leader>l <Plug>(easymotion-overwin-line)
" " Move to {char}{char}
map  <Leader>k <Plug>(easymotion-bd-f2)
nmap <Leader>k <Plug>(easymotion-overwin-f2)
nmap s <Plug>(easymotion-sn)
xmap s <Plug>(easymotion-sn)
omap z <Plug>(easymotion-sn)

" Disable default mappings
let g:EasyMotion_do_mapping = 0
" Characters to use as label
let g:EasyMotion_keys = ';HKLYUIOPNM,QWERTASDGZXCVBJF'
" Show target key with upper case to improve readability
let g:EasyMotion_use_upper = 1
" Jump to first match with enter & space
let g:EasyMotion_enter_jump_first = 1
let g:EasyMotion_space_jump_first = 1
" Turn on case sensitive feature
let g:EasyMotion_smartcase = 1
" keep cursor column with `JK` motions
let g:EasyMotion_startofline = 0


"=============================================================================
" Misc Settings
"=============================================================================
"----- GitGutter
nmap <silent> <C-g><C-n> <Plug>(GitGutterNextHunk)
nmap <silent> <C-g><C-p> <Plug>(GitGutterPrevHunk)

"----- NERD Tag
" コアファイルも含めるため.gitignoreを無視
let g:vim_tags_ignore_files = []
" Toggle Tagbar
nnoremap <silent> <Leader>G :<C-u>TagbarToggle<CR>
nnoremap <silent> <F8> :<C-u>TagbarToggle<CR>

"----- vim-showmarks
augroup show_marks_sync
  autocmd!
  autocmd BufReadPost * silent! DoShowMarks
augroup END

"----- vim-polyglot
" let g:polyglot_disabled = ['markdown']

"----- comfortable-motion.vim
" let g:comfortable_motion_no_default_key_mappings = 1
" nnoremap <silent> <M-d> :call comfortable_motion#flick(100)<CR>
" nnoremap <silent> <M-u> :call comfortable_motion#flick(-100)<CR>
" nnoremap <silent> <M-f> :call comfortable_motion#flick(200)<CR>
" nnoremap <silent> <M-b> :call comfortable_motion#flick(-200)<CR>
" nnoremap <silent> <S-PageDown> :call comfortable_motion#flick(200)<CR>
" nnoremap <silent> <S-PageUp> :call comfortable_motion#flick(-200)<CR>
"
" "noremap <silent> <ScrollWheelDown> :call comfortable_motion#flick(40)<CR>
" "noremap <silent> <ScrollWheelUp>   :call comfortable_motion#flick(-40)<CR>
" let g:comfortable_motion_interval = 2400.0 / 60
" let g:comfortable_motion_friction = 100.0
" let g:comfortable_motion_air_drag = 3.0
"
"----- open-browser.vim
" nmap <Leader>b <Plug>(openbrowser-smart-search)
" vmap <Leader>b <Plug>(openbrowser-smart-search)

"----- calendar.vim
" let g:calendar_google_calendar = 1
" let g:calendar_google_task = 1

"----- winresizer
" If you want to start window resize mode by `Ctrl+T`
let g:winresizer_start_key = '<M-T>'

let g:winresizer_keycode_left  = 104 " h
let g:winresizer_keycode_right = 108 " l
let g:winresizer_keycode_up    = 107 " k
let g:winresizer_keycode_down  = 106 " j

" If you cancel and quit window resize mode by `z` (keycode 122)
" let g:winresizer_keycode_cancel = 122"

"----- auto-pairs
let b:autopairs_enabled           = 0         " Default Off
let g:AutoPairsShortcutToggle     = '<M-P>'
let g:AutoPairsShortcutJump       = '<M-N>'
let g:AutoPairsShortcutFastWrap   = '<M-E>'
let g:AutoPairsShortcutBackInsert = '<M-B>'

"=============================================================================
" Experimental settings
"=============================================================================
"----- tag search settings for both ctags and cscope
" noremap <Leader>j   g]
" noremap <Leader>J   <C-w>g]
" noremap <Leader>T   :pop<CR>

map <Leader>g   :Gtags
" Show definition in the file.
map <Leader>h   :Gtags -f %<CR>
" Jump to definition or reference of under-cursor keyword
map <Leader>j   :GtagsCursor<CR>
map <C-]>       :GtagsCursor<CR>
map g]          :GtagsCursor<CR>
" Move line at Quickfix
map <C-n> :cn<CR>
map <C-p> :cp<CR>

" Pop up the stack
map <Leader>[   :pop<cr>
map <C-[>       :pop<cr>

"----- Arrow key: move screen line
noremap   <silent><Down>  gj
noremap   <silent><Up>    gk

"----- Ale
" Don't use shellcheck
" let g:ale_sh_shellcheck_executable = ''
let g:ale_linters = {
    \ 'sh': ['language_server'],
    \ 'bash': ['language_server'],
    \ }

" Command line option for languagetool
let g:ale_languagetool_options = '--autoDetect --disable "WHITESPACE_RULE,DASH_RULE[1]"'

" Command line option for mdl(Markdown linter implemented by ruby)
let g:ale_markdown_mdl_options = '--style "$XDG_CONFIG_HOME/vim/conf.d/mdl_style.rb"'

"----- Mouse
" Settings to use mouse
set mouse=nvh     " use mouse in normal, visual and help modes
set ttymouse=sgr  " currently well working on macOS(iTerm2+tmux) and linux(tmux)

"----- Buffer
" <Leader>n/p/b will next/prev/swap buffer
noremap <silent> <Leader>n   :bn<cr>
noremap <silent> <Leader>p   :bp<cr>
noremap <silent> <Leader>b   :b#<cr>

" Folding(:help fold.txt)
set foldmethod=syntax " manual / indent / marker / expr / syntax
set foldlevel=9999    " Don't close folding at start
set foldcolumn=0
augroup FoldingAutoCommand
  autocmd!
  " https://vim-jp.org/vim-users-jp/2009/10/08/Hack-84.html
  " Save fold settings.
  autocmd BufWritePost * if expand('%') != '' && &buftype !~ 'nofile' | mkview | endif
  autocmd BufRead * if expand('%') != '' && &buftype !~ 'nofile' | silent loadview | endif
  " Don't save options.
  set viewoptions-=options

  autocmd FileType vim  setlocal foldmethod=indent
  autocmd FileType yaml setlocal foldmethod=indent
  autocmd FileType json setlocal foldmethod=syntax
augroup END

"----- autodate
let autodate_format='%Y-%m-%dT%H:%M:%S%z'
let autodate_keyword_pre='Last Update: \['
let autodate_keyword_post='\]'

"----- MRU (Most recent used)
let MRU_File = '$XDG_DATA_HOME/vim/vim_mru_files'
let MRU_Max_Entries = 1000

" MBE(Mini Buffer Explorer)
" let g:miniBufExplUseSingleClick = 1

"----- Automatically clear command line result
" https://unix.stackexchange.com/a/613645
function! s:empty_message(timer)
  if mode() ==# 'n'
    echon ''
  endif
endfunction

augroup cmd_msg_cls
  autocmd!
  " autocmd CursorHold * echon ''
  autocmd CmdlineLeave :  call timer_start(15000, funcref('s:empty_message'))
  " autocmd CursorMoved *  call timer_start(10000, funcref('s:empty_message'))
augroup END

"----- Off the input method when leave from insert mode
" https://mitsuse.jp/2017/01/02/disable-input-source-on-insert-leave-in-vim/
if executable('swim')
  autocmd InsertLeave * :call system('swim use com.justsystems.inputmethod.atok33.Roman')
endif

"----- [TESTING] Check for 'modifyOtherKeys'
" imap  <C-[> This is "C-["
" imap  <C-{> This is "C-{"
" imap  <C-S-[> This is "C-S-["

"----- [TESTING] vim-autochange-bg
let g:autochg_bg_enable_on_vim_startup = 1
let g:autochg_bg_force_geoip = 1

"-----------------------------------------------------------------------------
" Appendix I: Mode and Map
"-----------------------------------------------------------------------------
"  [nore]map = normal, visual, select, operator (= Original-vim's map)
" n[nore]map = normal
" v[nore]map = visual, select
" s[nore]map = select
" x[nore]map = visual
" o[nore]map = operator
"  [nore]map!= insert, commandline (= Original-vim's map!)
" i[nore]map = insert
" l[nore]map = insert, commandline, Lang-Arg
" c[nore]map = commandline
" t[nore]map = terminal
