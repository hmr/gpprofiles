" Part of GPP(General Puropose Profiles)
" vim: ft=vim ts=2 sts=2 sw=2 expandtab fenc=utf-8 ff=unix
" Main Vim configuration

set encoding=utf-8              " Set utf-8 as default encoding.
scriptencoding utf-8

" XDG Base Dirctory conformance
if has('persistent_undo')
  set undodir=${XDG_DATA_HOME}/vim/undo
  set undofile
endif
set directory=${XDG_DATA_HOME}/vim/swap
set backupdir=${XDG_DATA_HOME}/vim/backup
set viewdir=${XDG_DATA_HOME}/vim/view
set viminfo+='1000,n${XDG_DATA_HOME}/vim/viminfo
set runtimepath+=${XDG_CONFIG_HOME}/vim,${VIMRUNTIME},${XDG_CONFIG_HOME}/vim/after

"-----------------------------------------------------------------------------
" Read configuration files
"-----------------------------------------------------------------------------
runtime conf.d/keymap.vim   " Keymap definition
runtime conf.d/vimplug.vim  " Vim-Plug

"----------------------------------------------------------------------------
" Misc settings [http://www.geek.sc/archives/977]
"----------------------------------------------------------------------------
filetype plugin indent on       " Use filetype plugin and auto indent
set fileencodings=utf-8,euc-jp,sjis,cp932,iso-2022-jp-3,iso-2022-jp,eucjp-ms,euc-jisx0213,ucs-bom
set fileformats=unix,dos,mac
set backspace=indent,eol,start  " allow backspacing over everything in insert mode
set autoindent                  " always set autoindenting on
set noswapfile                  " not to make swap file.
set nowritebackup               " not to make backup file.
set nobackup                    " not to backup
set history=50                  " keep 50 lines of command line history
set textwidth=0                 " default maximum width of text(0 means never use auto line break)
set tabstop=4                   " default tab width
set shiftwidth=0                " default indent width(0 means same as tabstop)
set expandtab                   " expand tab to space
set cursorline                  " show cursor line indicator
set cursorlineopt=both          " number / line / both
set number                      " show line number
"set ruler                      " show the cursor position all the time
set laststatus=2                " when the status line would be shown(2 means always)
"set statusline=%F%m%r%h%w\ \ \ \ %y\ lines:%L\%=(%l,%v)\ [%{&fileencoding}][%{&ff}]
set nohlsearch                  " not to highlight matching part
set incsearch                   " use incremental search
set ignorecase                  " ignore case distinctions
set showmatch                   " briefly jump to matched bracket
set noshowmode                  " not to show current mode at bottommost row
set title                       " allow vim change terminal's title
set virtualedit=block           " allow free cursor in visual block mode
set whichwrap=b,s,[,],<,>       " allow these keys move next or previous line(see help)
set ambiwidth=double            " a magic to deal with full width characters well
set wildmenu                    " use command line completion
set wildmode=longest,full       " completion mode(see help)
set noerrorbells                " no beep nor screen flush for error messages
set novisualbell                " no flush screen instead of beeping
set visualbell t_vb=            " visualbell is void(do nothing)
set list                        " show control characters such as tab or EOL.
"set listchars=tab:¬ª\ ,eol:‚Ü≤,space:‚ê£,trail:ÔΩ•,extends:‚ü©,precedes:‚ü®
set listchars=tab:¬ª\ ,eol:‚Ü≤,trail:ÔΩ•,extends:‚ü©,precedes:‚ü®
set showbreak=‚Ü™                 " string to put at the start of line wrapped. Useful values are '>' or '+++'
set hidden                      " not to unload and to hide the buffer when abondoned
"set paste                      " put Vim in Paste mode which is useful for pasting some text to Vim.
set modeline                    " use modeline

" Use <Leader>y <Leader>d <Leader>p to copy/cut/paste with system clipbord!
"set clipboard&            " reset clipboard as default
"set clipboard^=unnamed    " use system's clipboard

" No need to escape regular expression meta characters when search(very magic)
" nnoremap /  /\v

"=============================================================================
" Settings for Airline(lean & mean status/tabline for vim that's light as air )
" [https://github.com/vim-airline/vim-airline]
"=============================================================================
" let g:airline_theme='light'
" let g:airline_theme='tomorrow'
" let g:airline_theme='solarized'
" let g:airline_solarized_bg='dark'
let g:airline_theme='gruvbox'

" let g:airline_mode_map = {
"       \ 'n'  : ' [NORMAL] ',
"       \ 'i'  : ' <INSERT> ',
"       \ 'R'  : ' >REPLACE<',
"       \ 'c'  : ' [COMMAND]',
"       \ 'v'  : ' [VISUAL] ',
"       \ 'V'  : ' [V-LINE] ',
"       \ '' : ' [V-BLOCK]',
"       \ }

let g:airline_mode_map = {
      \ 'n'  : '[N]',
      \ 'i'  : '<I>',
      \ 'R'  : '>R<',
      \ 'c'  : 'COM',
      \ 'v'  : '[v]',
      \ 'V'  : '[V]',
      \ '' : 'V-B',
      \ }

"-+-+-+- Airline tab settings -+-+-+-
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#show_buffers = 1
let g:airline#extensions#tabline#tab_nr_type = 1
let g:airline#extensions#tabline#fnamemod = ':t'
let g:airline#extensions#tabline#formatter = 'unique_tail'

"-+-+-+- Airline status bar settings -+-+-+-
"let g:airline_section_a = airline#section#create(['mode', 'crypt', 'paste', 'spell', 'iminsert'])
"let g:airline_section_b = airline#section#create(['hunks', 'branch'])
"let g:airline_section_c = airline#section#create(['file'])
"let g:airline_section_x = airline#section#create(['tagbar', 'filetype'])
"let g:airline_section_y = airline#section#create(['ffenc'])
"let g:airline_section_z = airline#section#create(['linenr', 'maxlinenr'])

"-+-+-+- Airline font and symbols -+-+-+-
let g:airline_powerline_fonts = 1
let g:Powerline_symbols = 'fancy'

if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif

"let g:airline_left_sep = '¬ª'
"let g:airline_left_sep = '‚ñ∂'
"let g:airline_left_sep = 'ÓÇ∞'
"let g:airline_left_alt_sep = 'ÓÇ±'
let g:airline_left_sep = ''
let g:airline_left_alt_sep = ''

"let g:airline_right_sep = '¬´'
"let g:airline_right_sep = '‚óÄ'
"let g:airline_right_sep = 'ÓÇ≤'
"let g:airline_right_alt_sep = 'ÓÇ≥'
let g:airline_right_sep = ''
let g:airline_right_alt_sep = ''

let g:airline_symbols.linenr = '‚ò∞ '
"let g:airline_symbols.linenr = '‚êä'
"let g:airline_symbols.linenr = '‚ê§'
"let g:airline_symbols.linenr = '¬∂'

let g:airline_symbols.maxlinenr = ''
"let g:airline_symbols.maxlinenr = '„èë'
"let g:airline_symbols.maxlinenr = 'ÓÇ°'

"let g:airline_symbols.branch = 'ÓÇ†'
let g:airline_symbols.branch = '‚éá'

"let g:airline_symbols.paste = '<PASTE>'
let g:airline_symbols.paste = 'œÅ'
"let g:airline_symbols.paste = '√û'
"let g:airline_symbols.paste = '‚à•'

let g:airline_symbols.readonly = 'ÓÇ¢'
let g:airline_symbols.crypt = 'üîí'
let g:airline_symbols.spell = 'Íû®'       " Spell check
let g:airline_symbols.notexists = '‚àÑ'   " Sign for non-git file
let g:airline_symbols.whitespace = 'Œû' " Warning sign for white spaces

"------------------------------------------------
" Airline extensions
"------------------------------------------------
"-+-+-+- Airline with Ale(Syntax checker) -+-+-+-
let g:airline#extensions#ale#enabled = 1
let airline#extensions#ale#error_symbol = 'E:'
let airline#extensions#ale#warning_symbol = 'W:'
let airline#extensions#ale#show_line_numbers = 1
let airline#extensions#ale#open_lnum_symbol = '(L'
let airline#extensions#ale#close_lnum_symbol = ')'

"=============================================================================
" From How to boost your Vim productivity
" [https://sheerun.net/2014/03/21/how-to-boost-your-vim-productivity/]
"=============================================================================
" I. Space is your Leader
let mapleader = "\<Space>"

" II. Map your most frequent actions to Leader
"-- Type <Space>o to open a new file
"nnoremap <Leader>o :CtrlP<CR>
"-- Type <Space>w to save file (a lot faster than :w<Enter>)
nnoremap <Leader>w :w<CR>
"-- Enter visual line mode with <Space><Space>
nmap <Leader><Leader> V
"-- Copy & paste to system clipboard with <Space>p and <Space>y
vmap <Leader>y "+y
vmap <Leader>d "+d
nmap <Leader>p "+p
nmap <Leader>P "+P
vmap <Leader>p "+p
vmap <Leader>P "+P

" III. Use region expanding
vmap v <Plug>(expand_region_expand)
vmap <C-v> <Plug>(expand_region_shrink)

" IV. Discover text search object
vnoremap <silent> s //e<C-r>=&selection=='exclusive'?'+1':''<CR><CR>
    \:<C-u>call histdel('search',-1)<Bar>let @/=histget('search',-1)<CR>gv
omap s :normal vs<CR>

" V. Invent more awesome key mappings
"-- Automatically jump to end of text you pasted: paste multiple lines multiple times with simple ppppp
vnoremap <silent> y y`]
vnoremap <silent> p p`]
nnoremap <silent> p p`]
"-- Prevent replacing paste buffer on paste: select some text and paste over it without replacing paste buffer
function! RestoreRegister()
  let @" = s:restore_reg  " 's:' means script local variable(:help usr_41)
  return ''
endfunction
function! s:Repl()
  let s:restore_reg = @"
  return "p@=RestoreRegister()\<cr>"
endfunction
" vp doesn't replace paste buffer
vmap <silent> <expr> p <sid>Repl()

"-- Type 12<Enter><Enter> to go to line 12 (12G breaks my wrist)
"-- Hit Enter to go to end of file.
"-- Hit Backspace to go to beginning of file.
nnoremap <CR><CR> G
nnoremap <BS><BS> gg
"-- Quickly select text you just pasted:
noremap gV `[v`]
"-- Stop that stupid window from popping up:
map q: :q
noremap ; :

"=============================================================================
" Exit from any mode by Ctrl-C(Needless??)
"=============================================================================
noremap  <C-c> <ESC>
vnoremap <C-c> <ESC>
snoremap <C-c> <ESC>
xnoremap <C-c> <ESC>
onoremap <C-c> <ESC>
inoremap <C-c> <ESC>

" Don't back 1 charactor when leaving insert mode
augroup DoNotBack
  autocmd!
  autocmd InsertLeave * execute 'normal! l'
augroup END

"=============================================================================
" From Ëã•Âπ≤EmacsÈ¢®Âë≥„Å™vim„ÅÆ„Ç≠„ÉºË®≠ÂÆö
" [https://sites.google.com/site/fudist/Home/vim-nihongo-ban/tips/vim-key-emacs]
"=============================================================================
" sep„ÅåÁ©∫„Åß„Å™„Åë„Çå„Å∞„ÄÅsep„Çí„Çª„Éë„É¨„Éº„Çø„Å®„Åó„Å¶„Ç∏„É£„É≥„Éó„ÄÇË¶ã„Å§„Åã„Çâ„Å™„Åë„Çå„Å∞Ë¶ã„Åã„Åë„ÅÆË°åÈ†≠„Å∏„ÄÇ
" „Ç´„Éº„ÇΩ„É´‰ΩçÁΩÆ„ÅåË¶ã„Åã„Åë„ÅÆË°åÈ†≠„ÅÆÂ†¥Âêà„ÅØÁúü„ÅÆË°åÈ†≠„Å∏„ÄÇ
function! MyJumptoBol(sep)
  if col('.') == 1
    call cursor(line('.')-1, col('$'))
    call cursor(line('.'), col('$'))
    return ''
  endif
  if matchend(strpart(getline('.'), 0, col('.')), '[[:blank:]]\+') >= col('.')-1
    silent exec 'normal! 0'
    return ''
  endif
  if a:sep !=? ''
    call search('[^'.a:sep.']\+', 'bW', line('.'))
    if col('.') == 1
      silent exec 'normal! ^'
    endif
    return ''
  endif
  exec 'normal! ^'
  return ''
endfunction

" sep„ÅåÁ©∫„Åß„Å™„Åë„Çå„Å∞„ÄÅsep„Çí„Çª„Éë„É¨„Éº„Çø„Å®„Åó„Å¶„Ç∏„É£„É≥„Éó„ÄÇË¶ã„Å§„Åã„Çâ„Å™„Åë„Çå„Å∞Ë°åÊú´„Å∏„ÄÇ
function! MyJumptoEol(sep)
  if col('.') == col('$')
    silent exec 'normal! w'
    return ''
  endif
  if a:sep !=? ''
    let prevcol = col('.')
    call search('['.a:sep.']\+[^'.a:sep.']', 'eW', line('.'))
    if col('.') != prevcol
      return ''
    endif
  endif
  call cursor(line('.'), col('$'))
  return ''
endfunction

" IME„ÅÆÁä∂ÊÖã„Å®„Ç´„Éº„ÇΩ„É´‰ΩçÁΩÆ‰øùÂ≠ò„ÅÆ„Åü„ÇÅ<C-r>„Çí‰ΩøÁî®„Åó„Å¶„Ç≥„Éû„É≥„Éâ„ÇíÂÆüË°å„ÄÇ
function! MyExecExCommand(cmd, ...)
  let saved_ve = &virtualedit
  let index = 1
  while index <= a:0
    if a:{index} ==# 'onemore'
      silent setlocal virtualedit+=onemore
    endif
    let index = index + 1
  endwhile

  silent exec a:cmd
  if a:0 > 0
    silent exec 'setlocal virtualedit='.saved_ve
  endif
  return ''
endfunction

" Ë°åÊú´„Åß„ÇÇÂÅúÊ≠¢„Åô„ÇãÂçòË™ûÂçò‰ΩçÁßªÂãï„Ç≥„Éû„É≥„Éâ
function! MyMoveWord_i(cmd)
  let isEol = 0
  if col('$') == col('.')
    let isEol = 1
  endif
  let prevline = line('.')
  silent exec 'normal! '.a:cmd
  if line('.') == prevline
    return ''
  endif
  if a:cmd ==? 'w'
    if isEol == 0
      call cursor(prevline, 0)
      call cursor(line('.'), col('$'))
    endif
    if line('.') - prevline > 1
      call cursor(prevline+1, 0)
      call cursor(line('.'), col('$'))
    endif
  elseif a:cmd ==? 'b'
    call cursor(line('.'), col('$'))
    if prevline - line('.') > 1
      call cursor(prevline-1, 0)
      call cursor(line('.'), col('$'))
    endif
  endif
  return ''
endfunction

"-- Jump to BOL/EOL
vnoremap <C-a> 0
vnoremap <C-e> $
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
nnoremap <silent> <C-a> :call MyJumptoBol('„ÄÄ„ÄÇ„ÄÅÔºéÔºåÔºèÔºÅÔºü„Äå„Äç')<CR>
nnoremap <silent> <C-e> :call MyJumptoEol('„ÄÄ„ÄÇ„ÄÅÔºéÔºåÔºèÔºÅÔºü„Äå„Äç')<CR>
inoremap <silent> <C-a> <C-r>=MyJumptoBol('„ÄÄ„ÄÇ„ÄÅÔºéÔºåÔºèÔºÅÔºü„Äå„Äç')<CR>
inoremap <silent> <C-e> <C-r>=MyJumptoEol('„ÄÄ„ÄÇ„ÄÅÔºéÔºåÔºèÔºÅÔºü„Äå„Äç')<CR>

"-- Delete a character just after cursor(=Del key)
nnoremap <C-d> <Del>
cnoremap <C-d> <Del>
inoremap <silent> <Del> <C-g>u<Del>
inoremap <silent> <C-d> <C-g>u<Del>

"-- Delete a word
function DeleteForwardWord()
  silent execute 'normal! dw'
  return ''
endfunction

function DeleteBackwardWord()
  silent execute 'normal! db'
  return ''
endfunction

noremap  <silent> <M-d>  :call DeleteForwardWord()<CR>
noremap  <silent> <M-BS> :call DeleteBackwardWord()<CR>
noremap! <silent> <M-d>  <C-r>=DeleteForwardWord()<CR>
noremap! <silent> <M-BS> <C-w>

"-- Delete characters from cursor to EOL
nnoremap <C-k> D
inoremap <silent> <C-k> <C-g>u<C-r>=MyExecExCommand('normal! D','onemore')<CR>

"-- Move word by word
noremap  <silent> <M-Right> :call MyMoveWord_i('W')<CR>
noremap! <silent> <M-Right> <C-r>=MyMoveWord_i('W')<CR>
noremap  <silent> <M-Left>  :call MyMoveWord_i('B')<CR>
noremap! <silent> <M-Left>  <C-r>=MyMoveWord_i('B')<CR>

"=============================================================================
" Made by [hmr]
"=============================================================================
" „Éé„Éº„Éû„É´„É¢„Éº„Éâ„Åßa„Ç≠„Éº„ÇíÊäº„Åó„ÅüÂ†¥Âêà„ÄÅ„Ç´„Éº„ÇΩ„É´„ÅåË°åÊú´„Å´„ÅÇ„Çå„Å∞a„ÄÅ„Åù„Çå‰ª•Â§ñ„ÅØi„Å®„Åó„Å¶Âãï‰Ωú„Åô„Çã
function! AppendOrInsert()
  if col('.') == col('$') - 1
    exec 'startinsert!'
  else
    exec 'startinsert'
  endif
endfunction
noremap <silent> a :call AppendOrInsert()<CR>

" ÊåøÂÖ•„É¢„Éº„Éâ„Åß„ÇÇCtrl-z„Åß„Çµ„Çπ„Éö„É≥„Éâ„Åô„Çã
inoremap <C-z> <ESC><C-z>

" Ctrl+Arrow: move between the windows
noremap   <silent><C-Left>  :wincmd h<CR>
noremap   <silent><C-Down>  :wincmd j<CR> " or <C-w>j
noremap   <silent><C-Up>    :wincmd k<CR> " or <C-w>k
noremap   <silent><C-Right> :wincmd l<CR> " or <C-w>l
noremap!  <silent><C-Left>  <ESC>:wincmd h<CR> " or <C-w>h
noremap!  <silent><C-Down>  <ESC>:wincmd j<CR> " or <C-w>j
noremap!  <silent><C-Up>    <ESC>:wincmd k<CR> " or <C-w>k
noremap!  <silent><C-Right> <ESC>:wincmd l<CR> " or <C-w>l

" Shift+Ctrl+Arrow: move between the tabs
noremap   <silent><C-S-Left>  :tabn<CR>
noremap   <silent><C-S-Right> :tabp<CR>       " or <C-w>l
noremap!  <silent><C-S-Left>  <ESC>:tabn<CR>  " or <C-w>h
noremap!  <silent><C-S-Right> <ESC>:tabp<CR>  " or <C-w>l

" Testing for bash-readline
let readline_has_bash = 1

" PageUp/PageDown
function PageUpFull()
  silent execute 'normal!' "\<C-B>"
  return ''
endfunction

function PageDownFull()
  silent execute 'normal!' "\<C-F>"
  return ''
endfunction

function PageUpHalf()
  silent execute "normal! \<C-U>"
  silent execute 'normal! zz'
  return ''
endfunction

function PageDownHalf()
  silent execute "normal! \<C-D>"
  silent execute 'normal! zz'
  return ''
endfunction

noremap  <silent> <PageUp>     :call PageUpFull()<CR>
noremap  <silent> <PageDown>   :call PageDownFull()<CR>
noremap! <silent> <PageUp>     <C-r>=PageUpFull()<CR>
noremap! <silent> <PageDown>   <C-r>=PageDownFull()<CR>
noremap  <silent> <S-PageUp>   :call PageUpHalf()<CR>
noremap  <silent> <S-PageDown> :call PageDownHalf()<CR>
noremap! <silent> <S-PageUp>   <C-r>=PageUpHalf()<CR>
noremap! <silent> <S-PageDown> <C-r>=PageDownHalf()<CR>
vnoremap <PageUp>     <C-b>
vnoremap <PageDown>   <C-f>
vnoremap <S-PageUp>   <C-u>
vnoremap <S-PageDown> <C-d>

"-----------------------------------------------------------------------------
" Capture(): redirect command output to file [https://gist.github.com/hokaccha/380535]
"-----------------------------------------------------------------------------
" Capture {{{
command!
  \ -nargs=1
  \ -complete=command
  \ Capture
  \ call Capture(<f-args>)

function! Capture(cmd)
  redir => result
  silent execute a:cmd
  redir END

  let bufname = 'Capture: ' . a:cmd
  new
  setlocal bufhidden=unload
  setlocal nobuflisted
  setlocal buftype=nofile
  setlocal noswapfile
  silent file `=bufname`
  silent put =result
  1,2delete _
endfunction
" }}}

"-----------------------------------------------------------------------------
" [Meta-n] Toggle line number (https://qiita.com/smison/items/f392037f1164eba5cc74)
"-----------------------------------------------------------------------------
function ToggleNumber()
  if &number
    setlocal nonumber
  else
    setlocal number
  endif
endfunction
nmap <silent> <M-n> :silent call ToggleNumber()<CR>

"-----------------------------------------------------------------------------
" [Meta-h] Toggle search result highlighting (http://d.hatena.ne.jp/h1mesuke/20080327/p1)
"-----------------------------------------------------------------------------
function ToggleHighlight()
  if &hlsearch
    setlocal nohlsearch
  else
    setlocal hlsearch
  endif
endfunction
nmap <silent> <M-h> :silent call ToggleHighlight()<CR>

"-----------------------------------------------------------------------------
" [Meta-l] Toggle control character
"-----------------------------------------------------------------------------
function ToggleList()
  if &list
    setlocal nolist
  else
    setlocal list
  endif
endfunction
nmap <silent> <M-l> :silent call ToggleList()<CR>

"-----------------------------------------------------------------------------
" [Meta-p] Toggle paste mode
"-----------------------------------------------------------------------------
function TogglePaste()
  if &paste
    setlocal nopaste
  else
    setlocal paste
  endif
endfunction
nmap  <silent> <M-p> :silent call TogglePaste()<CR>

"-----------------------------------------------------------------------------
" [Meta-g] Toggle GitGutter
"-----------------------------------------------------------------------------
nmap <silent> <M-g> :silent call gitgutter#toggle()<CR>

"=============================================================================
" Settings for autocmd
"=============================================================================
if has('autocmd')
  augroup redhat
    autocmd!
    "In text files, always limit the width of text to 78 characters
    " autocmd BufRead *.txt set tw=78

    "When editing a file, always jump to the last cursor position
    autocmd BufReadPost *
          \ if line("'\"") > 0 && line ("'\"") <= line("$") |
          \     exe "normal! g'\"" |
          \ endif
    "don't write swapfile on most commonly used directories for NFS mounts or USB sticks
    autocmd BufNewFile,BufReadPre /media/*,/mnt/* set directory=~/tmp,/var/tmp,/tmp
    "start with spec file template
    autocmd BufNewFile *.spec 0r /usr/share/vim/vimfiles/template.spec

    " Trying to disable textwidth limitation.
    " autocmd FileType text setlocal textwidth=0
  augroup END
endif

"=============================================================================
" NERDTree(A tree explorer plugin for vim) [https://github.com/preservim/nerdtree]
"=============================================================================
map <Leader>t :NERDTreeToggle<CR>
augroup nertree_g
  autocmd!
  autocmd BufEnter * if (winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree()) | q | endif
augroup END
let g:NERDTreeDirArrowExpandable = '‚ñ∏'
let g:NERDTreeDirArrowCollapsible = '‚ñæ'

" Ë°®Á§∫ÂπÖ
let g:NERDTreeWinSize=30
" „Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÇíË°®Á§∫
let g:NERDTreeShowBookmarks=1
" Ë¶™„Éá„Ç£„É¨„ÇØ„Éà„É™„Å∏ÁßªÂãï
let g:NERDTreeMapUpdir='<C-u>'
" „Éï„Ç°„Ç§„É´„ÅÆÈñã„ÅçÊñπ
let g:NERDTreeMapOpenSplit='<C-j>'
let g:NERDTreeMapOpenVSplit='<C-l>'
" „Éï„Ç°„Ç§„É´„ÇíÈñã„ÅÑ„Åü„ÇâNERDTree„ÇíÈñâ„Åò„Çã
let g:NERDTreeQuitOnOpen=1
" Èö†„Åó„Éï„Ç°„Ç§„É´„ÇíË°®Á§∫
let g:NERDTreeShowHidden=0
" ÈùûË°®Á§∫„Éï„Ç°„Ç§„É´
let g:NERDTreeIgnore=['\.git$', '\.clean$', '\.swp$', '\.bak$', '\~$']

augroup vimrc_nerdtree
  autocmd!
  " ‰ªñ„ÅÆ„Éê„ÉÉ„Éï„Ç°„Çí„Åô„Åπ„Å¶Èñâ„Åò„ÅüÊôÇ„Å´NERDTree„ÅåÈñã„ÅÑ„Å¶„ÅÑ„Åü„ÇâNERDTree„ÇÇ‰∏ÄÁ∑í„Å´Èñâ„Åò„Çã„ÄÇ
  autocmd bufenter * if (winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree()) | q | endif

  " TreeÂÜÖ„Åß„ÅØ5„Åö„Å§ÁßªÂãï„Åô„Çã
  autocmd FileType nerdtree nnoremap 5j
  autocmd FileType nerdtree nnoremap 5k
augroup END

"=============================================================================
" Settings for NERD Commenter
"=============================================================================
" Create default mappings
let g:NERDCreateDefaultMappings = 1
" Add spaces after comment delimiters by default
let g:NERDSpaceDelims = 1
" Use compact syntax for prettified multi-line comments
let g:NERDCompactSexyComs = 1
" Align line-wise comment delimiters flush left instead of following code indentation
let g:NERDDefaultAlign = 'left'
" Set a language to use its alternate delimiters by default
let g:NERDAltDelims_java = 1
" Add your own custom formats or override the defaults
let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }
" Allow commenting and inverting empty lines (useful when commenting a region)
let g:NERDCommentEmptyLines = 1
" Enable trimming of trailing whitespace when uncommenting
let g:NERDTrimTrailingWhitespace = 1
" Enable NERDCommenterToggle to check all selected lines is commented or not
let g:NERDToggleCheckAllLines = 1

" While the plugin does not directly support motions,
" you can leverage its support for selections to do something very similar.
" For example, to add motions to toggle comments on the paragraph text object you could use:
"nnoremap <silent> <leader>c} V}:call NERDComment('x', 'toggle')<CR>
"nnoremap <silent> <leader>c{ V{:call NERDComment('x', 'toggle')<CR>

"=============================================================================
" quickhl.vim(Quickly highlight multiple word) [https://github.com/t9md/vim-quickhl]
"=============================================================================
nmap <Leader>m <Plug>(quickhl-manual-this)
xmap <Leader>m <Plug>(quickhl-manual-this)
nmap <Leader>r <Plug>(quickhl-manual-reset)
xmap <Leader>r <Plug>(quickhl-manual-reset)
nmap <Leader>c <Plug>(quickhl-manual-clear)
vmap <Leader>c <Plug>(quickhl-manual-clear)
"nmap <Space>w <Plug>(quickhl-manual-this-whole-word)
"xmap <Space>w <Plug>(quickhl-manual-this-whole-word)
"nmap <Space>j <Plug>(quickhl-cword-toggle)
"nmap <Space>] <Plug>(quickhl-tag-toggle)
"map H <Plug>(operator-quickhl-manual-this-motion)

"=============================================================================
" Settings for cscope [:help if_cscop]
"=============================================================================
if has('cscope') && filereadable('/usr/local/bin/cscope')
  set cscopeprg=/usr/local/bin/cscope
  set cscopetagorder=0
  set cscopetag
  set nocscopeverbose
  " add any database in current directory
  if filereadable('cscope.out')
    cs add cscope.out
    " else add database pointed to by environment
  elseif $CSCOPE_DB !=? ''
    cs add $CSCOPE_DB
  endif
  set cscopeverbose
endif

"=============================================================================
" Settings for terminal, color, visual and syntax highlighting
"=============================================================================

" Enable paste bracketting
if &term !~? 'xterm'  " Except for xterm
  let &t_BE = "\e[?2004h" " Enter paste bracketting
  let &t_BD = "\e[?2004l" " Exit  paste bracketting
  exec "set t_PS=\e[200~"
  exec "set t_PE=\e[201~"
endif

if &t_Co > 2 || has('gui_running')  " Only for color environment

  " Reset and enable syntax highlighting(for w/o reset use ':syntax enable')
  syntax on

  if has('termguicolors')
    set termguicolors
    if &term !~? 'xterm'  " for $TERM != 'xterm'
      let &t_8f = "\e[38;2;%lu;%lu;%lum" " Default foreground color
      let &t_8b = "\e[48;2;%lu;%lu;%lum" " Default background color
    endif
  endif

  " Color scheme settings
  try
    set background=dark

    " colorscheme monokai

    " -- settings for molokai
    " let g:molokai_original=1
    " let g:rehash256=1
    " colorscheme molokai

    " -- settings for sublime-monokai
    let g:sublimemonokai_term_italic=1

    " -- with vim's mainline Java
    " let java_comment_strings=1
    " let java_highlight_functions=1
    " let java_highlight_java_lang_ids=1

    " -- with 'fatih/vim-go'
    " let g:go_highlight_format_strings=1
    " let g:go_highlight_function_arguments=1
    " let g:go_highlight_function_calls=1
    " let g:go_highlight_functions=1
    " let g:go_highlight_operators=1
    " let g:go_highlight_types=1
    " let g:go_highlight_extra_types=1
    " let g:go_highlight_fields=1
    " let g:go_highlight_generate_tags=1
    " let g:go_highlight_variable_assignments=1
    " let g:go_highlight_variable_declarations=1

    " with 'StanAngeloff/php.vim'
    " let g:php_var_selector_is_identifier=1

    " colorscheme sublimemonokai
    colorscheme gruvbox
  catch
    colorscheme default
  endtry

  " Use italic font for comment
  highlight Comment cterm=italic

  " show vertical line at col 100 if possible
  if (exists('+colorcolumn'))
    set colorcolumn=100
  endif

  if g:colors_name ==# 'molokai'
    if has('termguicolors')
      highlight Comment   guifg=#95917E
      highlight Visual    guibg=#af5f00
      highlight VisualNOS guibg=#af5f00

      " Change background color by mode
      augroup InsertHook
        autocmd!
        autocmd InsertEnter * highlight Normal guibg=#263026
        autocmd InsertLeave * highlight Normal guibg=#262626
      augroup END
    else
      highlight Comment   ctermfg=247
      highlight Visual    ctermbg=130
      highlight VisualNOS ctermbg=130
    endif
  endif

  if g:colors_name ==# 'sublimemonokai'
    highlight SignColumn guibg=#383a3e
  endif

endif

"-- Change cursor color depends on InputMethod status
if has('gui_running') && (has('xim') || has('multi_byte_ime'))
  "highlight Cursor guifg=NONE guibg=Green
  highlight CursorIM guifg=Black guibg=Red
endif

"-- Change cursor shape by mode
if has('vim_starting')
  " 1-2: Block
  " 3-4: Underline
  " 5-6: Vertical
  " (*) Odd number is with blinking
  let &t_EI .= "\e[1 q"   " Normal mode
  let &t_SI .= "\e[5 q"   " Insert mode
  let &t_SR .= "\e[6 q"   " Replace mode
endif

"-- ScroolUp/ScrollDown by mouse wheel
"map <S-ScrollWhellUp> <C-Y>
"map <S-ScrollWhellDown> <C-U>

"=============================================================================
" Additional settings for MacVim
"=============================================================================
if has('gui_macvim')
  set antialias

  " Font for MacVim
  set guifont=MesloLGS\ NF\ Regular:h14
  "set guifont=RictyDiminished-Regular:h15

  " MacVim now supports trasparency!
  " set transparency=7

  " Supress cursor brinking [http://www.linuxpowertop.org/known.php]
  let &guicursor .= ',a:blinkon0'

  " Terminal setting
  let &t_ZH = '[3m'   " Enter italic mode
  let &t_ZR = '[23m'  " Exit italic mode

  " WinResizer can handle MacVim's window
  let g:winresizer_gui_enable = 1
endif

" "=============================================================================
" " Settings for fzf.vim
" "=============================================================================
" set runtimepath+=/usr/local/opt/fzf
" let g:fzf_buffers_jump = 1
" nnoremap <silent> <Leader>ff :<C-u>Ag<CR>
" nnoremap <silent> <Leader>fh :<C-u>History<CR>
" nnoremap <silent> <Leader>ft :<C-u>call fzf#vim#tags(expand('<cword>'))<CR>
" nnoremap <silent> <Leader>fb :<C-u>Buffers<CR>
" nnoremap <silent> <Leader>fgs :<C-u>GFiles?<CR>
" nnoremap <silent> <Leader>fgf :<C-u>GFiles<CR>
" nnoremap <silent> <Leader>fm :<C-u>Marks<CR>
" let g:fzf_layout = { 'down': '30%' }
" let g:fzf_action = {
"       \ 'ctrl-t': 'tab split',
"       \ 'ctrl-j': 'split',
"       \ 'ctrl-l': 'vsplit' }
"
" augroup vimrc_fzf
"   autocmd!
"   autocmd FileType fzf tnoremap <buffer> <leader>z <Esc>
" augroup END

" "=============================================================================
" "Settings for vim-easymotion
" "=============================================================================
" map  <Leader>e <Plug>(easymotion-prefix)
" " Move to word
" map  <Leader>j <Plug>(easymotion-bd-w)
" nmap <Leader>j <Plug>(easymotion-overwin-w)
" " Move to line
" map  <Leader>l <Plug>(easymotion-bd-jk)
" nmap <Leader>l <Plug>(easymotion-overwin-line)
" " Move to character
" map  <Leader>k <Plug>(easymotion-bd-f)
" nmap <Leader>k <Plug>(easymotion-overwin-f)

"=============================================================================
" Misc Settings
"=============================================================================
"----- GitGutter
nmap <silent> <C-g><C-n> <Plug>GitGutterNextHunk
nmap <silent> <C-g><C-p> <Plug>GitGutterPrevHunk

"----- NERD Tag
" „Ç≥„Ç¢„Éï„Ç°„Ç§„É´„ÇÇÂê´„ÇÅ„Çã„Åü„ÇÅ.gitignore„ÇíÁÑ°Ë¶ñ
let g:vim_tags_ignore_files = []
" Toggle Tagbar
nnoremap <silent> <Leader>g :<C-u>TagbarToggle<CR>

"----- vim-showmarks
augroup show_marks_sync
  autocmd!
  autocmd BufReadPost * silent! DoShowMarks
augroup END

"----- vim-polyglot
" let g:polyglot_disabled = ['markdown']

" "----- comfortable-motion.vim
" let g:comfortable_motion_no_default_key_mappings = 1
" nnoremap <silent> <M-d> :call comfortable_motion#flick(100)<CR>
" nnoremap <silent> <M-u> :call comfortable_motion#flick(-100)<CR>
" nnoremap <silent> <M-f> :call comfortable_motion#flick(200)<CR>
" nnoremap <silent> <M-b> :call comfortable_motion#flick(-200)<CR>
" nnoremap <silent> <S-PageDown> :call comfortable_motion#flick(200)<CR>
" nnoremap <silent> <S-PageUp> :call comfortable_motion#flick(-200)<CR>
"
" "noremap <silent> <ScrollWheelDown> :call comfortable_motion#flick(40)<CR>
" "noremap <silent> <ScrollWheelUp>   :call comfortable_motion#flick(-40)<CR>
" let g:comfortable_motion_interval = 2400.0 / 60
" let g:comfortable_motion_friction = 100.0
" let g:comfortable_motion_air_drag = 3.0
"
"----- open-browser.vim
nmap <Leader>b <Plug>(openbrowser-smart-search)
vmap <Leader>b <Plug>(openbrowser-smart-search)

"----- calendar.vim
" let g:calendar_google_calendar = 1
" let g:calendar_google_task = 1

"----- winresizer
" If you want to start window resize mode by `Ctrl+T`
let g:winresizer_start_key = '<M-T>'

let g:winresizer_keycode_left  = 104 " h
let g:winresizer_keycode_right = 108 " l
let g:winresizer_keycode_up    = 107 " k
let g:winresizer_keycode_down  = 106 " j

" If you cancel and quit window resize mode by `z` (keycode 122)
" let g:winresizer_keycode_cancel = 122"

"----- auto-pairs
let b:autopairs_enabled           = 0         " Default Off
let g:AutoPairsShortcutToggle     = '<M-P>'
let g:AutoPairsShortcutJump       = '<M-N>'
let g:AutoPairsShortcutFastWrap   = '<M-E>'
let g:AutoPairsShortcutBackInsert = '<M-B>'

"=============================================================================
" Experimental settings
"=============================================================================
"----- tag search settings for both ctags and cscope
noremap <Leader>j   g]
noremap <Leader>J   <C-w>g]
noremap <Leader>t   :pop<CR>

"----- Arrow key: move screen line
noremap   <silent><Down>  gj
noremap   <silent><Up>    gk

"----- Ale
" Command line option for languagetool
let g:ale_languagetool_options = '--autoDetect --disable "WHITESPACE_RULE,DASH_RULE[1]"'

" Command line option for mdl(Markdown linter implemented by ruby)
let g:ale_markdown_mdl_options = '--style "$XDG_CONFIG_HOME/vim/conf.d/mdl_style.rb"'

" Settings to use mouse
set mouse=a                     " use mouse in all modes
set ttymouse=xterm2             " code system sent when a mouse button is clicked
"-----------------------------------------------------------------------------
" Appendix I: Mode and Map
"-----------------------------------------------------------------------------
"  [nore]map = normal, visual, select, operator (= Original-vim's map)
" n[nore]map = normal
" v[nore]map = visual, select
" s[nore]map = select
" x[nore]map = visual
" o[nore]map = operator
"  [nore]map!= insert, commandline (= Original-vim's map!)
" i[nore]map = insert
" l[nore]map = insert, commandline, Lang-Arg
" c[nore]map = commandline
" t[nore]map = terminal
